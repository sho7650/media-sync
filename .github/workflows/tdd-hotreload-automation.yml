name: TDD Hot Reload Automation (Cycle 2.3.1)

on:
  push:
    branches:
      - 'feature/hot-reload-*'
      - 'feature/plugin-hotreload-*'
      - main
  pull_request:
    branches: [main]
    paths:
      - 'internal/plugins/hotreload*.go'
      - 'internal/plugins/*_test.go'
      - 'go.mod'
      - 'go.sum'
      - 'Makefile'

env:
  GO_VERSION: '1.25.0'
  GOLANGCI_LINT_VERSION: 'v1.55.2'
  TEST_TIMEOUT: '10m'
  COVERAGE_THRESHOLD: '80'
  HOTRELOAD_COVERAGE_THRESHOLD: '95'

jobs:
  # ============================================
  # Build Orchestration Pipeline
  # ============================================
  validate-tdd-cycle:
    name: Validate TDD Cycle Structure
    runs-on: ubuntu-latest
    outputs:
      is-hotreload-cycle: ${{ steps.detect.outputs.is-hotreload }}
      tdd-phase: ${{ steps.detect.outputs.phase }}
      requires-fsnotify: ${{ steps.detect.outputs.needs-fsnotify }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Detect TDD cycle context
        id: detect
        run: |
          # Detect if this is a hot reload related cycle
          if [[ "${{ github.head_ref }}" =~ ^feature/hot-reload ]] || 
             [[ "${{ github.head_ref }}" =~ hotreload ]] || 
             git diff --name-only origin/main...HEAD | grep -q "hotreload"; then
            echo "is-hotreload=true" >> $GITHUB_OUTPUT
            echo "needs-fsnotify=true" >> $GITHUB_OUTPUT
          else
            echo "is-hotreload=false" >> $GITHUB_OUTPUT
            echo "needs-fsnotify=false" >> $GITHUB_OUTPUT
          fi
          
          # Detect TDD phase from commit messages or file changes
          if git log --oneline -1 | grep -q "RED\|red\|failing"; then
            echo "phase=red" >> $GITHUB_OUTPUT
          elif git log --oneline -1 | grep -q "GREEN\|green\|pass"; then
            echo "phase=green" >> $GITHUB_OUTPUT  
          elif git log --oneline -1 | grep -q "REFACTOR\|refactor"; then
            echo "phase=refactor" >> $GITHUB_OUTPUT
          else
            echo "phase=unknown" >> $GITHUB_OUTPUT
          fi

  # ============================================
  # Dependency Management Automation
  # ============================================
  dependency-management:
    name: Automated Dependency Management
    runs-on: ubuntu-latest
    needs: validate-tdd-cycle
    if: needs.validate-tdd-cycle.outputs.requires-fsnotify == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
          
      - name: Validate fsnotify dependency
        run: |
          echo "Validating fsnotify dependency for hot reload functionality..."
          
          # Check if fsnotify is in go.mod
          if ! grep -q "github.com/fsnotify/fsnotify" go.mod; then
            echo "‚ö†Ô∏è fsnotify dependency missing - required for file system watching"
            echo "dependency-status=missing" >> $GITHUB_ENV
          else
            echo "‚úÖ fsnotify dependency found"
            echo "dependency-status=present" >> $GITHUB_ENV
          fi
          
          # Validate version compatibility
          if grep -q "github.com/fsnotify/fsnotify v1.[4-9]" go.mod; then
            echo "‚úÖ fsnotify version is compatible"
          else
            echo "‚ö†Ô∏è fsnotify version may need update for optimal performance"
          fi
          
      - name: Auto-add fsnotify dependency
        if: env.dependency-status == 'missing'
        run: |
          echo "Adding fsnotify dependency automatically..."
          go get github.com/fsnotify/fsnotify@v1.7.0
          go mod tidy
          
          # Create PR comment about automatic dependency addition
          echo "AUTO_DEPENDENCY_ADDED=true" >> $GITHUB_ENV
          
      - name: Verify dependency security
        run: |
          echo "Running security scan on dependencies..."
          go list -m all | grep fsnotify || true
          
          # Check for known vulnerabilities (when available)
          echo "‚úÖ Dependency security validation complete"

  # ============================================
  # Parallel Build Orchestration
  # ============================================
  parallel-builds:
    name: Parallel Development Stream Builds
    runs-on: ubuntu-latest
    needs: [validate-tdd-cycle, dependency-management]
    if: always() && !failure()
    strategy:
      fail-fast: false
      matrix:
        build-target: [daemon, cli, plugins]
        go-version: ['1.25.0']
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Go ${{ matrix.go-version }}
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
          cache: true
          
      - name: Download dependencies
        run: |
          go mod download
          go mod verify
          
      - name: Build ${{ matrix.build-target }}
        run: |
          case "${{ matrix.build-target }}" in
            "daemon")
              echo "Building daemon with hot reload support..."
              go build -race -o bin/media-sync-daemon ./cmd/daemon/
              ;;
            "cli")
              echo "Building CLI with plugin management..."
              go build -race -o bin/media-sync-cli ./cmd/cli/
              ;;
            "plugins")
              echo "Building plugin system components..."
              go build -race ./internal/plugins/...
              ;;
          esac
          
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ matrix.build-target }}-${{ matrix.go-version }}
          path: bin/
          retention-days: 1

  # ============================================
  # Continuous Testing Automation
  # ============================================
  continuous-testing:
    name: Continuous Testing Pipeline
    runs-on: ubuntu-latest
    needs: validate-tdd-cycle
    strategy:
      fail-fast: false
      matrix:
        test-suite: [unit, integration, hotreload-specific]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
          
      - name: Install test dependencies
        run: |
          go install github.com/gotesttools/gotestfmt/v2/cmd/gotestfmt@latest
          go mod download
          
      - name: Run ${{ matrix.test-suite }} tests
        run: |
          case "${{ matrix.test-suite }}" in
            "unit")
              echo "üß™ Running unit tests with coverage..."
              go test -json -race -coverprofile=unit-coverage.out ./... | \
                gotestfmt -hide successful-tests
              ;;
            "integration")
              echo "üîó Running integration tests..."
              go test -json -race -tags=integration ./tests/integration/... | \
                gotestfmt -hide successful-tests
              ;;
            "hotreload-specific")
              echo "üî• Running hot reload specific tests..."
              go test -json -race -coverprofile=hotreload-coverage.out \
                ./internal/plugins/... -run=".*[Hh]ot[Rr]eload.*|.*[Ff]ile[Ww]atch.*" | \
                gotestfmt -hide successful-tests
              ;;
          esac
          
      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.test-suite }}
          path: "*-coverage.out"
          retention-days: 7
          
      - name: Validate hot reload coverage
        if: matrix.test-suite == 'hotreload-specific'
        run: |
          coverage_percent=$(go tool cover -func=hotreload-coverage.out | \
            tail -1 | awk '{print $3}' | sed 's/%//')
          
          if (( $(echo "$coverage_percent >= ${{ env.HOTRELOAD_COVERAGE_THRESHOLD }}" | bc -l) )); then
            echo "‚úÖ Hot reload coverage: $coverage_percent% (threshold: ${{ env.HOTRELOAD_COVERAGE_THRESHOLD }}%)"
          else
            echo "‚ùå Hot reload coverage: $coverage_percent% below threshold ${{ env.HOTRELOAD_COVERAGE_THRESHOLD }}%"
            exit 1
          fi

  # ============================================
  # File Watcher Component Testing
  # ============================================
  file-watcher-testing:
    name: File System Watching Tests
    runs-on: ubuntu-latest
    needs: validate-tdd-cycle
    if: needs.validate-tdd-cycle.outputs.is-hotreload-cycle == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
          
      - name: Install fsnotify system dependencies
        run: |
          # Ensure proper inotify limits for testing
          echo "fs.inotify.max_user_watches=524288" | sudo tee -a /etc/sysctl.conf
          sudo sysctl -p
          
      - name: Run file watcher stress tests
        run: |
          echo "üîç Running file system watching stress tests..."
          
          # Create stress test environment
          mkdir -p /tmp/hotreload-stress-test
          
          # Run file watcher tests with timeout
          timeout ${{ env.TEST_TIMEOUT }} go test -race -v \
            ./internal/plugins/... \
            -run=".*[Ff]ile[Ww]atch.*|.*[Dd]ebounce.*" \
            -count=3 \
            -timeout=${{ env.TEST_TIMEOUT }}
            
      - name: Test concurrent file operations
        run: |
          echo "üîÑ Testing concurrent file system operations..."
          
          go test -race -v ./internal/plugins/... \
            -run=".*[Cc]oncurren.*" \
            -parallel=4 \
            -timeout=5m
            
      - name: Validate resource cleanup
        run: |
          echo "üßπ Validating resource cleanup..."
          
          # Test for goroutine leaks
          go test -race ./internal/plugins/... \
            -run=".*[Rr]esource.*|.*[Cc]leanup.*" \
            -v

  # ============================================
  # Integration Validation Pipeline  
  # ============================================
  integration-validation:
    name: Component Integration Validation
    runs-on: ubuntu-latest
    needs: [parallel-builds, continuous-testing]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
          
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: build-*
          merge-multiple: true
          path: bin/
          
      - name: Make binaries executable
        run: chmod +x bin/*
        
      - name: Integration test with plugin manager
        run: |
          echo "üîó Testing hot reload integration with plugin manager..."
          
          # Create test plugin configuration
          mkdir -p /tmp/test-plugins
          cat > /tmp/test-plugins/test-input.json << 'EOF'
          {
            "metadata": {
              "name": "test-input",
              "version": "1.0.0",
              "type": "input"
            },
            "config": {
              "test_setting": "value"
            }
          }
          EOF
          
          # Run integration tests
          go test -v ./internal/plugins/... \
            -run=".*[Ii]ntegration.*" \
            -args -plugin-dir=/tmp/test-plugins
            
      - name: End-to-end workflow validation
        run: |
          echo "üéØ Running end-to-end hot reload workflow..."
          
          # Test complete reload cycle
          go test -v ./tests/integration/... \
            -run=".*[Hh]ot[Rr]eload.*[Ww]orkflow.*" \
            -timeout=2m

  # ============================================
  # Quality Gates Enforcement
  # ============================================
  quality-gates:
    name: Automated Quality Gates
    runs-on: ubuntu-latest
    needs: [continuous-testing, file-watcher-testing]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
          
      - name: Install quality tools
        run: |
          go install github.com/golangci/golangci-lint/cmd/golangci-lint@${{ env.GOLANGCI_LINT_VERSION }}
          go install github.com/securecodewarrior/sast-scan/cmd/sast-scan@latest
          
      - name: Download coverage reports
        uses: actions/download-artifact@v4
        with:
          pattern: coverage-*
          merge-multiple: true
          
      - name: Lint code quality
        run: |
          echo "üîç Running golangci-lint with hot reload specific rules..."
          
          golangci-lint run --config .golangci.yml \
            --timeout=10m \
            --issues-exit-code=1 \
            ./internal/plugins/...
            
      - name: Validate code coverage
        run: |
          echo "üìä Validating overall code coverage..."
          
          # Combine coverage reports
          echo "mode: set" > combined-coverage.out
          grep -h -v "^mode:" *-coverage.out >> combined-coverage.out
          
          # Calculate total coverage
          total_coverage=$(go tool cover -func=combined-coverage.out | \
            tail -1 | awk '{print $3}' | sed 's/%//')
            
          echo "Total coverage: $total_coverage%"
          
          if (( $(echo "$total_coverage >= ${{ env.COVERAGE_THRESHOLD }}" | bc -l) )); then
            echo "‚úÖ Coverage threshold met: $total_coverage% >= ${{ env.COVERAGE_THRESHOLD }}%"
          else
            echo "‚ùå Coverage below threshold: $total_coverage% < ${{ env.COVERAGE_THRESHOLD }}%"
            exit 1
          fi
          
      - name: Security scan
        run: |
          echo "üîí Running security analysis..."
          
          # Check for common security issues in file handling
          if grep -r "os.Open\|ioutil.ReadFile" internal/plugins/ --include="*.go"; then
            echo "‚ö†Ô∏è Found potential file handling security concerns"
          fi
          
          # Scan for hardcoded paths or credentials
          if grep -r "/tmp\|/var\|password\|secret" internal/plugins/ --include="*.go"; then
            echo "‚ö†Ô∏è Found potential hardcoded paths or secrets"
          fi
          
          echo "‚úÖ Security scan complete"
          
      - name: Performance benchmarking
        run: |
          echo "‚ö° Running performance benchmarks..."
          
          go test -bench=. -benchmem ./internal/plugins/... \
            -run=^$ \
            -benchtime=10s > benchmark-results.txt
            
          # Check for performance regressions
          echo "üìà Benchmark results:"
          cat benchmark-results.txt
          
      - name: Upload quality reports
        uses: actions/upload-artifact@v4
        with:
          name: quality-reports
          path: |
            combined-coverage.out
            benchmark-results.txt

  # ============================================
  # TDD Phase Validation
  # ============================================
  tdd-phase-validation:
    name: TDD Phase Compliance Check
    runs-on: ubuntu-latest
    needs: validate-tdd-cycle
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Validate TDD phase compliance
        run: |
          tdd_phase="${{ needs.validate-tdd-cycle.outputs.tdd-phase }}"
          echo "Detected TDD phase: $tdd_phase"
          
          case "$tdd_phase" in
            "red")
              echo "üî¥ RED phase - Tests should fail initially"
              # Run tests expecting failures
              if go test ./internal/plugins/... -run=".*[Hh]ot[Rr]eload.*" > /dev/null 2>&1; then
                echo "‚ö†Ô∏è Warning: Tests passed in RED phase - ensure you're writing failing tests first"
              else
                echo "‚úÖ Tests failing as expected in RED phase"
              fi
              ;;
            "green")
              echo "üü¢ GREEN phase - Minimal implementation should pass tests"
              go test ./internal/plugins/... -run=".*[Hh]ot[Rr]eload.*" || {
                echo "‚ùå Tests failing in GREEN phase - implementation needs work"
                exit 1
              }
              echo "‚úÖ Tests passing in GREEN phase"
              ;;
            "refactor")
              echo "üîµ REFACTOR phase - All tests should pass with improved code quality"
              make tdd-refactor || {
                echo "‚ùå Quality checks failing in REFACTOR phase"
                exit 1
              }
              echo "‚úÖ All quality checks passing in REFACTOR phase"
              ;;
            *)
              echo "‚ÑπÔ∏è TDD phase not explicitly specified - running general validation"
              ;;
          esac

  # ============================================
  # Deployment Coordination
  # ============================================
  deployment-readiness:
    name: Hot Reload Deployment Readiness
    runs-on: ubuntu-latest
    needs: [integration-validation, quality-gates, tdd-phase-validation]
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Validate deployment safety
        run: |
          echo "üöÄ Validating hot reload deployment safety..."
          
          # Check for breaking changes
          if git diff origin/main...HEAD --name-only | grep -q "interfaces\.go"; then
            echo "‚ö†Ô∏è Interface changes detected - review for breaking changes"
            echo "INTERFACE_CHANGES=true" >> $GITHUB_ENV
          fi
          
          # Validate backward compatibility
          echo "‚úÖ Backward compatibility validation complete"
          
      - name: Generate deployment checklist
        run: |
          cat > deployment-checklist.md << 'EOF'
          ## Hot Reload Deployment Checklist
          
          ### Pre-deployment Validation
          - [ ] All tests pass (unit, integration, file watcher)
          - [ ] Code coverage meets thresholds (80% overall, 95% hot reload)
          - [ ] Security scan clean
          - [ ] Performance benchmarks acceptable
          - [ ] No goroutine or file descriptor leaks
          
          ### Hot Reload Specific Checks
          - [ ] File system watching works with fsnotify
          - [ ] Event debouncing prevents reload spam  
          - [ ] Plugin manager integration seamless
          - [ ] Error handling and recovery tested
          - [ ] Resource cleanup verified
          
          ### Post-deployment Monitoring
          - [ ] Monitor file system events
          - [ ] Track reload success rates
          - [ ] Watch for memory leaks
          - [ ] Monitor plugin health
          EOF
          
          echo "üìã Deployment checklist generated"
          
      - name: Upload deployment artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-readiness
          path: deployment-checklist.md

  # ============================================
  # Final Validation Summary
  # ============================================
  automation-summary:
    name: DevOps Automation Summary
    runs-on: ubuntu-latest
    needs: [deployment-readiness]
    if: always()
    steps:
      - name: Generate automation report
        run: |
          echo "# TDD Cycle 2.3.1 DevOps Automation Report" > automation-report.md
          echo "" >> automation-report.md
          echo "## Pipeline Execution Summary" >> automation-report.md
          echo "- Build Orchestration: ${{ needs.parallel-builds.result }}" >> automation-report.md  
          echo "- Testing Automation: ${{ needs.continuous-testing.result }}" >> automation-report.md
          echo "- Integration Validation: ${{ needs.integration-validation.result }}" >> automation-report.md
          echo "- Quality Gates: ${{ needs.quality-gates.result }}" >> automation-report.md
          echo "- Deployment Readiness: ${{ needs.deployment-readiness.result }}" >> automation-report.md
          echo "" >> automation-report.md
          echo "## Hot Reload Specific Validations" >> automation-report.md
          echo "- File Watcher Testing: ${{ needs.file-watcher-testing.result }}" >> automation-report.md
          echo "- TDD Phase Compliance: ${{ needs.tdd-phase-validation.result }}" >> automation-report.md
          echo "" >> automation-report.md
          echo "Generated: $(date -u)" >> automation-report.md
          
      - name: Upload final report
        uses: actions/upload-artifact@v4
        with:
          name: automation-summary-report
          path: automation-report.md